# ＥＳ：０５_RTOS
## 特徴と構成
### RTOS定義
#### ある制限時間内に特定の処理を行うことが要求されるシステム
##### 汎用OS（GPOS）との比較
###### 共通点
* ハードウェアの抽象化とソフトウェアの移植性向上
* 複数プログラムの並列処理
* 処理負荷点の最適化
###### 相違点
* 限定されたメモリサイズ
* デイスクレス起動のサポート
* リアルタイム性（実時間性）
* 高信頼性
* OSを構成する要素のカスタマイズが可能
#### 構成
##### 
###### カーネル分類
* モノリシックカーネルOS
    * 標準的な機能を盛り込んだ状態で最適化されるOS
        * 一般にサービスの実行に伴うプロセス切替えの回数が少なくて済むが、特定のアプリケーションに対しては不要な機能が含まれてしまう場合がある
* マイクロカーネルOS
    * カーネルの機能を必要最小限に絞り、サイズを可能な限り小さくしたうえで、ターゲットシステムで必要とされる機能だけを追加して構成するOSである
        * 特定のアプリケーション利用に特化した、必要な機能だけを提供するOSを構築しやすいが、追加した機能が別プロセスとなり、プロセス切替の回数が増える場合がある
###### システムコール
* APがRTOSのサービス利用する時のAPI関数群である
    * 主な分類
        * タスク管理
            * タスクの生成／消滅／起動／停止／状態移行といった、タスク自体の制御を行う機能を提供する
                * 例
                    * act_tsk(tno)
                        * tnoで指定したタスクを生成して起動する
                    * ext_tsk()
                        * 次タスクを終了させる
                    * abo_tsk(tno)
                        * tnoで指定した他タスクを終了させる
        * 同期・通信機能
            * インベトフラグ／メールボックス／セマフォなど、タスク間での同期制御及びタスク間通信を実現する機能
                * 例
                    * イベントフラグ
                        * set_evf(pattern)
                            * patternで指定したイベントフラグをセットする。指定できるイベントフラグ数上限がある（例：最大６４）
                        * clr_evf(pattern)
                            * patternで指定したイベントフラグをクリアする
                        * wait_evf(pattern, mode)
                            * patternで指定したイベントフラグが設定されるのを待つ
                                * modeによってAND、ORの指定で、複数イベントフラグを指定は可能
                                * 複数のタスクが同じイベントフラグを指定できる、この場合、指定した条件を満たしたすべてのタスクが、実行可能状態となる
                        * poll_evf(pattern, mode)
                            * patternで指定したイベントフラグが設定されているかどうかをチェクする
                        * get_evf(evfbuf)
                            * すべてのイベントフラグをevfbufに読み出す
                    * セマフォ
                        * get_sem(sem)
                            * semで指定したセマフォを獲得するまで待つ
                        * poll_sem(sem)
                            * semで指定したセマフォを獲得できるかどうかをチェックし、獲得できる場合は獲得する。（非同期）
                        * rel_sem(sem)
                            * semで指定したセマフォを解放する
                    * メールボックス
                        * send_mbx(mbox. mailp)
                            * mboxで指定したメールボックスに、mailpで示されるメールを送る
                        * recv_mbx(mbox, malibuf)
                            * mboxで指定したメールボックスからメールを受信するまで待つ。メールを受信すると、mailbufにメールへのポインタを格納する
                        * poll_mbx(mbox, mailbuf)
                            * mboxで指定したメールボックスにメールが届いているかどうかをチェックする。メールを受信していれば、mailbufにメールへのポインタを格納する
        * 時間管理
            * システムタイマの設定／取得、周期起動タスクの管理、タスクの実行遅延など、時間管理に関する機能を提供する
                * 例
                    * dly_tsk(time)
                        * timeで指定した時間だけ、呼出し元のタスクを待たせる
        * メモリ管理
            * メモリ領域の確保／解放と言った、メモリ管理に関する機能を提供する
                * 例
                    * get_mem(size, member)
                        * sizeで指定したバイト数分のメモリ領域を、メモリプールから確保する。確保したメモリ領域の先頭アドレスをmembufに格納する
                    * rel_mem(mempt)
                        * get_memで確保したメモリ領域を解放する。解放するメモリ領域の先頭アドレスをmemptで指定する
## タスク管理
### 状態遷移
#### 
##### 実行可能状態：Ready
##### 実行状態：Running
##### 待ち状態：Waiting
##### 休止状態：Dormant
##### 未登録状態：Non−Existent
### スケジューリング
#### ランドロビン方式：Round Robin：RR
##### 分割されたCPU時間をタスクに順次割り振るスケジューリング方式である
###### 量子時間：time quantum／タイムスライス：time slice
* 分割されたCPU時間の呼び方
###### タイムシェアリング
* 量子時間を複数のタスクの均等に分配する方式
##### RRではすべてのタスクを平等に取り扱う、優先度を区別しない、RTOSではそれぞれのタスクに割り当てられたCPU時間内で必要な処理が確実に終わるように設計することが求まれる
#### 到着順方式：First−Come First−Served：FCFS
#### 最短ジョブ優先方式：Shortest Job First：SJF
##### 処理時間が短いタスクに高い優先度を与えることによってジョッ部の待ち時間を短く、結果としてシステム全体のスループットを高くする方式である
#### 最小残余時間優先方式：Shortest Remaining Time First：SRTF
##### 現在の実行中のものも含めてタスクが完了するまでに要する時間の短いタスクに高い優先度を与える方式
#### 優先度方式
##### タスクに優先順位を設定し、その優先度に基づいてタスクを切り替えるスケジューリング方式
###### 実行より優先度を動的に変える設計にもある
#### プリエンプティブ方式
##### 優先度のより高いタスクが起動すると、現在実行しているタスクの実行権を横取りして動作させることを特徴とするタスク制御の方式である
###### 実行権を横取りすることをプリエンプトする（preempt）、名詞はプリエンプション（preemption）
* RTOSではほぼ必須の機能
#### コンテキスト切替
##### 一つの処理を実行している時のCPUの状態をコンテキストといい、状態の保存・復元を伴うタスクの切り替え動作をコンテキスト切替（コンテキストスイッチ）と呼ぶ
#### レートモノトニック：rate monotonic
##### タスクごとに一定周期ごとに起動するスケジューリング方式、優先度高いタスクの実行周期になると、プリエンプションを発生
###### 起動周期が短いタスクにより高い優先度を与えた方が全体的にスムーズ
* プロセッサ利用率有利の前提条件
    * 単一プロセッサ
    * すべてのタスクが周期的
    * ハードリアルタイムシステム
    * デッドラインは、周期の終わり
    * 各タスクは独立
    * 各タスクの最大実行時間は、既知で一定
    * プリエンプティブスケジューリング
#### デッドラインスケジューリング
##### 周期的なタスクのスケジューリングにおいて、タスクが必ずデッドラインを守る方式　
#### EDF：Earliest Deadine First
##### 最もデッドラインが早く到着するタスクを優先的に実行する方式である。同じ場合、周期が短いタスクから実行。周期も同じ場合には、タスク番号の小さいタスクから実行
###### レートモノトニックがタスクの優先度をタスク生成時に決定する「静的優先度割付」であるのに対して、EDFは動的に切ったされる
#### LLF：Least Laxit First／LST：Least Slack Time
##### プロセスのslack  time余裕時間に基づいて優先度を設定する
#### 優先度継承方式（プライオリティインヘリタンス方式：Priority Inheritance Protocol）
##### 依存関係があるタスクに、依存元タスクを待ちする際に、依存先タスクの優先度を一時的依存元タスクと同レベルに上げるの方式
###### タスクがリソース待ちになった時、そのリソースを確保しているタスクの優先度をリソース待ちタスクの優先度まで引き上げる．クリティカルセクション終了後、優先度を元に戻す
* 問題点
    * デッドロックが生じる可能性がある
    * 連続ブロックキングが生じやすい
        * 連続ブロッキング：高い優先度のタスクが何回もブロックされる現象（低優先度タスクの優先度を上げたため）
#### プライオリティシーリング方式：Priority Celling Protocol
##### 優先度継承方式の改良
###### 各クリティカルセクション（CS）にプライオリティシーリング値を付ける。シーリング値は、そのCSを共有しているプロセスの中で、最も優先度の高いプロセスの優先度とする
###### プロセスPがCSに入ろうとした場合の処理
* 自分の優先度が、他プロセスによって既にロックされているすべてのCSのシーリング値よりも、高い時のみCSに入ることができる
## 同期制御
### 代表的な仕組み
#### イベントフラグ
##### evf
###### 
#### メールボックス
##### mbx
###### 
#### セフフォ：semaphore
##### 排他的な制御が必要な資源の管理に用いられる同期制御方式
###### 資源を獲得する操作をP操作、資源を解放する操作をV操作
* 
## 優先度の逆転とデッドロック
### 優先度の逆転：Priority Inversion
#### セマフォによる資源の排他制御の結果、優先度の低いタスクが優先度の高いタスクより早く実行されてしまう現象
##### 上の図はタスクAがリソース待ちのでCよろ遅延になった、下の図はタスクAがBの原因で実行さらに遅延になった
### デッドロック
#### 複数のタスクが同じ資源を獲得しようとして取り合いが起こり、いずれのタスクも動作できなくなった状態を指す
##### 四つの条件同時に成立する時に発生
###### 相互排除
* 同時に一つのタスクしか使うことができない資源があること
###### 獲得と待機
* あるタスクが、ある資源を獲得している状態で、別の資源の獲得要求を出した状態で待機していること
    * 予防
        * タスクの実行前に必要とするすべての資源を獲得する（非効率）
###### プリエンプトできない
* 資源の横取りができないこと
    * 予防
        * 資源の獲得に失敗したときは、現在獲得している資源をすべて解放する方法である（場合より使える）
###### 循環待機
* 二つ以上のタスクにおいて、資源の獲得と要求のリンクが循環していることである
    * 予防
        * 複数の資源に対して、獲得する順序をルール化する方法
## 性能指標
### 主な基準
#### CPU時間
##### CPUが処理を実行している時間
#### 待ち時間
##### 命令を受けてから処理が開始されるまでの時間
#### 入出力時間
##### 処理に関連する入出力にかかる時間
#### ターンアラウンドタイム：TAT
##### 命令を受けてから処理結果を全て出し終わるまでの時間
###### ＝待ち時間＋CPU時間＋入出力時間
#### 応答時間：Response time
##### 命令を受けてから処理結果を出し始めるまでの時間
#### スループット：Throughput
##### 単位時間当たりの処理件数
#### CPU使用率
##### CPU利用時間／システム稼働時間
###### RTOSのCPU利用時間＝各タスクのCPU時間合計
### リアルタイム性
#### RT保証するため、システム上同時に発生する可能性のある処理を全て動作させたことを想定して処理時間の見積もりを行うことが必要である
##### 方法：ワーストケース見積もり
###### 検討項目
* 並行して動作する各タスクの優先度
* 入出力と内部処理の負荷バランス
* 割込みの発生頻度と処理負荷
* 割込み禁止期間の適切な設定
#### 分類
##### ハードリアルタイム
###### 制限時間内に処理を終えないと動作が成立しなくなるモノ
* 例：自動車のエンジン制御、制御機器のモーションコントロール
##### ソフトリアルタイム
###### 制限時間内に処理を終えなくてもシステムとしての動作は継続可能であるが、利用者にとっての価値が低下するモノ
* 例：DVDプレーヤでの再生がある、再生中にリモコンのボタンを連打してボタン操作に対する処理負荷が増え、再生デコーダの処理が間に合わなくなるような時、再生のコマ落ちが発生するが、再生の続行は可能である
