# 基礎理論

## １．１ 計算の基礎理論

### 計算基礎理論

- 概念

	- ‘情報理論

		- 情報伝達を数学の体系

	- 情報量

		- 転送すべき情報を発生する源で、情報の種類とその発生の確率で特徴付けられ
		- 生起確率

			- I(J) = - log2 P(J)

	- 平均情報量
	- 情報源

		- マルコフ情報源

			- ある時点で起こった事象の生成確率が、それ以前に起こったn個の事象の生成確率に依存する情報源である
			- 単純マルコフ情報源

				- n＝1

		- エルゴード情報源

			- 統計的な確率をある値に収束する

### 論理と集合

- 論理

	- 論理演算

		- 論理和 OR
		- 論理積 AND
		- 排他の論理和 XOR または EOR

			- 論理和 と 論理積の非 の論理積

		- 論理否定 NOT
		- 否定論理和  論理和の否定
		- 否定論理積 論理積の否定
		- 等価演算 排他の論理和の否定

	- カルノー図 卡诺图

		- 最小项函数
		- 四角枠うちのセルすべて1の場合、論理式を簡素可能

- 集合

	- 集合の表現

		- 要素の列挙
		- 要素を算術式で表現
		- 空集合

	- 概念

		- 部分集合
		- 真部分集合

			- 部分集合 AND ≠

		- 普遍集合（全体集合）
		- 補集合

	- 演算

		- 和集合
		- 積集合
		- 差集合
		- 排他の論理和集合

### グラフ理論

- 定義

	- 点の集合Ｖと辺の集合Ｅを、G＝（Ｖ，Ｅ）
	- 分類

		- 完全グラフ

			- 全ての2点間において1本の辺が存在するグラフ

		- 有向グラフ＆无向グラフ
		- 木

			- 閉じていないグラフ
			- 巡回法

				- 順序木

					- 幅優先順
					- 深さ優先順

						- 親先行順
						- 親中間順
						- 親後行順

			- その他用語

				- 探索木

					- 木を構成する各点に値を持つ要素を格納した木

				- 部分木

					- 子木

		- 構造

			- ヒープ（堆）

				- 深さの浅い順に、同じ深さで左から順に節が配置される2分木
				- 親の節の値＜この節の値（または親の節の値＞子の節の値）

			- 2分探索木（二叉树）

				- 左の子の節の値＜親の節の値＜右の子の節の値

			- AVL木（平衡二叉树）

				- 部分木の深さが最大でも１しか違わない2分探索木

			- Ｂ木

				- 根から全ての葉までの深さが等しく
				- 多分木、多分m＝2の時は2分検索木になる
				- 根以外の各節はk個以上の要素を持つ
				- 各節は最大2k個の要素を持つ
				- 各節は要素数を1を加えた数の子を持つ

			- Ｂ＋木

				- 葉のみ要素を持つのＢ木

## 数学基礎名詞

### 相乗平均値

- n個の正の数がある時、これらの全部の積のn乗根である

## １．２ プログラム基礎理論

### オートマトン／状態機械／Automaton／Status Machine

- 有限オートマトン

	- 初期状態
	- 状態遷移表
	- 入力を受理された

- プッシュダウン・オートマトン

	- 状態集合
	- 入力集合
	- スタック
	- 開始状態
	- スタック初期状態
	- 最終状態
	- 転移関係 transition

### 計算量と正当性

- 計算量

	- 分類

		- .

			- 領域計算量
			- 時間計算量

		- .

			- 最大計算量
			- 平均計算量

	- O記法

		- 加算：計算量の大きい方のプログラムと同じようにする
		- 乘算：階乗
		- O（１）：計算量が定数時間、処理時間がデータ量に依存しないこと

- 正当性

	- 部分正当性（partial correctness）

		- 結果返ればその結果が正しい
		- 必ず結果を得るとは限れない

	- 全正当性

		- 有限な時間内に停止する（termination）
		- 必ず結果を得られる
		- 結果は正しい

### 演算と精度

- 標準

	- IEEE754（1985）

		- 32ビット Float

			- Ｓ：符号 部、1ビット
			- Ｅ：指数部、8ビット

				- バイアス値：127（2の（8ー1）階乘ー1）、マイナス0あり

					- バイアス値

						- 負数を正数値にするため加算の値（参照：补码、演算には符号を処理不要なエンコーディング）
						- 比較する際に、特に処理なしで、浮動数字を比較可能

			- Ｍ：仮数部、23ビット

				- 正規化表現のため、実際こっちで表現しているのは小数部だけ

			- 計算式：（ー1）ｓ（2Ｅー127）（１．Ｍ）

		- 64ビット Double
		- 特別な値

			- ♾

				- 指数部は全0、仮数部は全0以外

			- NaN

				- 指数部は全1、仮数部は全0以外

			- 0

				- 指数部と仮数部は全0

	- イクセス64

		- 符号1ビット、指数7ビット、仮数24ビット、仮数部は0ー1に正規化している

- 誤差

	- 分類

		- 絶対誤差

			- 測定値、観測値、計算値なとと真値の絶対差

		- 相対誤差

			- 絶対誤差／真値    ≒   絶対誤差／測定値

		- 糸統誤差

			- 何らかの原因で、測定値、観測値、計算値などの結果が真値と比較して、同じ方向に偏ってしまう誤差

	- 原因

		- 丸め誤差

			- 端数処理を丸めという
			- ある桁の次の方を切り捨て、切り上げ、四捨五入の処理

		- 桁落ち

			- 有効桁数がなくなる現象

				- ほぼ等しい数字同士の引き算
				- 絶対値がほぼ等しく符号が異なる2数の加算

		- 情報落ち

			- 仮数部に入りきらなくなるケース

				- 大きな値と小さな値の加減算

			- 小さな数字が事実無視された
			- 多量な数字加算する際に、絶対値が小さなからしないと積み残し誤差が出てくる可能

				- 積み残し

					- アルゴリズムより誤差が出ない可能性が、情報落ちの説明のケースより誤差がでてくる

		- 打ち切り誤差

			- 極限操作を有限のところを打ち切り
			- つまり、適当な誤差範囲で計算を打ち切り

		- エンディアン（バイトオーダ）

			- endian
			- ビッグエンディアン
			- リトルエンディアン

## １．３ 数理応用

### 確率と確率分布

- 順列

	- n個のものからr個（r≦n）を選んで並べる並べ方nPr

- 組合せ

	- nこのものからr個を選び出す組合せnCr

- 階乗

	- 0！＝1

- 確率

	- 一つの事象を起こりうる可能性を表す数
	- 事象Aの数n（A）／全事象の数n

- 余事象

	- 事象Aに対して、A出ない事象をAの余事象

- 排反事象

	- 二つ事象のうち、一方が発生すれば他方は発生しない事象

### PERT（Program Evaluation and Review Technique）

- 概念

	- 日程計画に使用、プロジェクトをイベントに分割し、ターゲットにそれぞれの依頼関係と所用時間を表すグラフ

- 表記法

	- アローダイアグラム

		- 実線

			- アロー（実作業）

		- 点線

			- ダミー作業、実作業がないですが、依存関係がある

- 前進計算

	- 最早結合点時刻を計算、イベントを最も早く開始できる日程を算出

- 後進計算

	- 最遅結合点時刻を計算、イベントを最も遅く開始出来る日程を算出

- クリティカルパス

	- 最早結合点時刻と最遅結合点時刻の等しいイベントを結んだ経路

### 待ち行列

- 代表理論：M／M／m

	- MM：サービス要求の発生頻度分布、サービスの時間分布

		- M：ランダムあるいは指数分布
		- G：一般分布
		- D：一定

	- m：サービス窓口（サーバ）の数

- 公式

	- 平均到着率

		- 観測値：単位時間当たりの平均到着数（件／時間）

	- 平均処理率

		- 測定値：単位時間当たりの平均処理数（件／時間）

	- 利用率

		- 平均到着率／平均処理率

			- 0人待ちの確率：1ー利用率
			- n人待ちの確立：利用率のn冪✖️（1ー利用率）

	- 平均サービス時間（平均処理時間）

		- 1／平均処理率

			- ミリ秒単位？

	- 平均滞留ジョブ数

		- 利用率／（1 ー 利用率）

			- 証明：冪和の差分法

	- 平均待ち時間

		- 平均サービス時間 ✖️ 平均滞留ジョブ数

	- 平均応答時間

		- 平均待ち時間 ➕ 平均サービス時間

## １．４ プログラム言語	

### プログラム構造

- 再帰（リカーシブ：recursive）

	- プログラム実行中、実行中の手続きを自体を呼び出すことが可能な構造

- 再使用可能（リユーザブル：reusable）

	- 再入可能（リエントラント：reentrant）

		- 同時に複数のプログラムで使用可能

	- 逐次最使用可能

		- 同時には使用不可能（待ち行列を作る）

- 再配置可能（リロケータブル：relocatable）

	- プログラム実行中に主記憶の格納位置を動的に変更可能

		- 今の時代のほぼ常識ですが、実アドレス時代の話かも

### 基本制御構造

- 連接（連続）

	- gotoや分岐なしの逐次的に実行される分だけで構成する論理構造

		- 構造化プログラムではgoto、break labelなどJump機制は非推奨

- 選択

	- if then else構造
	- 多分岐構造

- 繰返し

	- 回数繰返し構造
	- 前判定繰返し構造
	- 後判定繰返し構造

### 手続きと関数

- 手続き

	- 呼出しと復帰の機能を揃えたプログラムの一部

- 関数

	- 手続きにおいて値を与えると結果を戻す機能を持ったものである

- 引数

	- 手続きや関数とデータをやり取りする変数
	- 値呼出し

		- コピー渡す

	- 参照呼出し

		- アドレス渡す

- 領域確保

	- 靜的割当

		- プログラム起動された時に確保

	- 動的割当

		- ブロック（モジュール）が起動された時に割当てる

			- 一般コンピュータとサービスではほとんどこれ

### コンパイラ技法

- 処理手順

	- 字句解析
	- 構文解析
	- 意味解析
	- 最適化

		- 畳込み

			- 定数をあらかじめ計算しておく

		- 式の簡略化

			- 同じ式の置き換えより

		- ループの再編

			- 値変わらない定数を外に出す
			- 多重ループを一重ループに置き換え

		- レジストリ割当の再編
		- サブルーチンの組込

			- インライン展開

	- コード生成

		- 機械語プログラム生成

- 計算の逆ポーランド記法（後置記法）

	- コンパイラするときに、算術式の機械語に変換する、数式の（）を外し、実際に計算する順序で演算式があらわれる。基本的には、変数の後ろに演算子を配置する
	- 例：XQ＝XPC✖️＝XAB➕C✖︎  元：X＝（A＋B）x C

### プログラム言語の種類・特徴

- プログラム言語

	- 手続き型

		- 問題の解決手順を手続き（アルゴリズム）に寄って記述
		- C、COBOL、ORTRAN、BASIC、PL・I、Pascal

	- 関数型

		- 関数定義と関数呼び出して構成、データをリストに置き換えて処理
		- LISP、APL

	- 論理型

		- データの関係を論理式によって定義し、その関係を証明しながら推論を繰り返す
		- 推論が完了と実行が終わるため、最適な解を求めるのはバックトラッキング（backtracking）を実施
		- Prolog

	- オブジェクト指向型

		- データと手続きをカプセル化したオブジェクトによる処理
		- Java、C＋＋、Smalltalk、Swift

- マークアップ言語

	- SGML

		- Standard Generalized Markup Lanuguage
		- 文書の論理構造や意味構造をタグで指定することで標準化したもので、大規模な文書データベースを構築することが出来る。複雑のためよく簡素化して利用する。

	- HTML

		- HyperText Markup Language
		- インターネット向けのSGMLカスタマイズ

	- XML

		- eXtensible Markup Language
		- インターネット最適化、ユーザ独自のタグを指定することができる

- スクリプト言語

	- Visual Basic
	- JavaScript

		- Ajax（Asynchronous JavaScript ➕ XML）

	- Perl

		- Practical Extraction and Report Language
		- テキスト検索や抽出、レポート作成向きの言語で、インタプリタ型。CGIの開発などで使われ

	- PHP

		- Hypertext Preprocessor

### アルゴリズム

- 整列アルゴリズム

	- 選択ソート

		- 計算量：O（n2）
		- 整列対象範囲の最小値を選択しながら整列

	- バブルソート

		- 計算量：O（n2）
		- 隣りあう要素の大小を比較しながら整列

	- シェルソート

		- 計算量：O（n2/3）以下
		- 飛び飛びの要素に挿入ソートを適用

			- 安定なアルゴリズムではなく、飛び飛びの間隔より計算量が違う、1の場合挿入ソートと同じ
			- 飛び飛びより移動量が減らす

	- クイックソート

		- 計算量：O（nlog（n））（平均）
		- 計算量：O（n2）（最大）
		- 基準値より大きな要素と小さな要素に分割しながら整列

			- 考察中最も高速が、整列済みの配列に適用すると、最悪のO（n2）になる

	- ヒープソート

		- 計算量：O（nlog（n））
		- ヒープの根が最大値（または最小値）であることを利用

			- 完全2分木：各ノードは2個の子で構成され、同じ深さであれば左から右に順にノードを詰められている木

		- ソート前の準備のヒープ構成の計算量はO（n）

			- 再構成は根の左右の子の大きな方を入れ替え

	- マージソート

		- 計算量：O（nlog（n））
		- 整列済みの２つ配列をマージして１つにする

			- 分割→…→最小限まで分割→マージ

	- 挿入ソート

		- 計算量：O（n2）
		- 整列済みの配列に対し、追加要素を適切な位置に挿入

- 探索アルゴリズム

	- 線形探索

		- 計算量：O(n)
		- 並んだデータに対してブロック探索可能

	- 2分探索

		- 計算量：O(log(n))
		- 並んだデータを前提です

	- ハッシュ探索

		- 計算量：O(1)
		- キー値を予め決めたハッシュ関数よって演算して検索
		- 衝突が発生する際に対処必要

	- 文字列検索

		- 単純な検索（力任せ法）

			- 配列の先頭から順次に1文字ずつずらしながらひかくしてく

		- BM法（BoyerーMoore method）

			- 検索対象文字列の右側から比較（例：文字数5のキーワードの場合、第5個目から比較）
			- 比較の同時に後ろへどのぐらいスキップがわかるため、効率的によい

*XMind: ZEN - Trial Version*